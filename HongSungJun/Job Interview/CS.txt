1. 시간복잡도와 공간복잡도
보통 위 두 가지 개념은 알고리즘에 관해 공부를 할 때 들어볼 수 있는 단어이다. 
시간복잡도란 알고리즘의 수행시간의 분석 결과, 공간 복잡도는 알고리즘의 메모리 사용량에 대한 분석 결과이다.
시간복잡도를 계산 할 때 보통 경우를 3가지로 나눠서 계산을 한다. Best case, Worst Case, Average Case
계산을 한 결과를 표현하는 방법으로는 Big O 표기법이 있는데, O(1) O(logn) O(n) O(nlogn) O(n^2) O(n^3) O(2^n) O(n!)
위 순서로 n이 커질수록 처리해야하는 데이터가 많아져 시간이 오래걸리게 된다.

공간 복잡도 계산의 경우 매우 간단하다. 메모리를 얼마나 사용했는지를 계산하면 된다. 크기가 n인 배열을 입력했을 때,
알고리즘이 내부에서 n*n의 이차원 배열을 생성한다면 이 알고리즘의 공간복잡도는 n^2이 된다.
보통 공간복잡도는 시간복잡도에 비해 중요하지 않게 생각되는 경우가 많다. 그러나 빅데이터를 처리하는 겅우에는 공간복잡도가 커지게 되는 경우
메모리에 한번에 올라가지 않아 실행이 되지 않는 문제가 발생 할 수도 있다. 이러한 경우에는 데이터를 나눠서 처리하고 나중에 병합하는 방식으로 처리한다.

2. 스택과 큐
스택은 후입선출 구조로 나중에 들어온 데이터가 먼저 나가게 된다. 그러므로 top에는 가장 나중에 들어온 데이터를 가리키고 있다.
삽입을 하는 연산을 push 삭제를 하는 연산은 pop라고 한다. 
여기서 비어있는 스택에서 pop를 실행하면 stack underflow가 발생하며, 정해진 스택용량를 초과해서 push를 하는 경우에는 stack overflow가 발생한다.

큐는 스택과 다르게 선입선출 구조로, 먼저 들어온 데이터가 제일 먼저 나가는 구조이다. 
스택은 top을 통해서 삭제와 삽입이 이루어지지만, 큐는 한쪽에서는 삽입 다른 한쪽에서는 삭제가 이루어진다.
삭제연산만 수행되는 곳은 front 삽입이 이루어지는 곳은 rear라고 한다. 
큐에서의 삽입연산은 enQueue 삭제연산은 deQueue라고 한다.

3. 배열과 연결리스트
배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 구조이다. 연속적으로 저장이 되어 있기 때문에 index를 통한 접근이 용이하다.
배열의 시간복잡도는 탐색의 경우 접근하고자 하는 인덱스를 알고 있는 경우 O(1), 순차탐색시에는 O(n)
삽입과 삭제는 중간에 삽입과 삭제를 하는 경우 O(n), 끝에서 삽입과 삭제를 하는 경우에는 O(1)

연결리스트는 여러 개의 노드들이 순차적으로 연결된 형태를 갖는 구조이다. 첫번째 노드를 헤드, 마지막 노드를 테일이라고 한다.
각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져 있다. 배열과는 다르게 연속적으로 메모리를 사용하지 않는다.
배열과는 다르게 순차적으로 접근해야하는 경우 불리할 수도 있으나, 삽입과 삭제에서는 용이하다.
연결리스트의 시간복잡도는 탐색에서는 O(n) 삽입과 삭제의 경우에는 O(1)

두 가지를 비교하면 배열의 장점은 인덱스를 통한 빠른 접근 가능, 연결리스트는 삽입과 삭제가 용이
단점은 배열의 경우, 삽입/삭제가 오래걸림, 배열 중간에 있는 데이터가 삭제되는 경우 공간의 낭비가 발생
연결리스트는 임의 접근이 불가능, 처음부터 탐색을 진행해야 한다.

4. 트랜잭션과 acid
트랜잭션은 query를 하나의 묶음 처리해서 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 rollback, 오류없이 실행을 마치면 commit을 하는 
실행단위를 의미한다.
즉, 한 번의 질의가 실행되면 모두 수행되거나, 모두 수행되지 않는 작업수행의 논리적인 단위이다.
이를 사용하는 이유는 데이터의 부정합을 방지하고 함이다. 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만
처리하도록 하면 되는데, 이는 효율이 너무 떨어진다. 
즉, 병렬로 처리할 수 밖에 없는 상황에서 부정합을 방지하고자 트랜잭션을 사용하는 것이다.

원자성: 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 의미, 작업 단위를 일부분만 실행하지 않는다는 것을 의미
일관성: 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것을 의미, 트랜잭션이 수행되지 전에 데이터의 타입이 정수형이었는데, 수행되고 나서
문자열이 되지 않는 것을 의미한다
격리성: 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것, 서로 간섭이 불가능하다.
지속성: 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 의미, commit을 하면 현재 상태는 영원히 보장되는 것을 의미한다.

5. 정규화의 개념 및 장단점
정규화는 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정이다. 분해를 하면 여러 개의 릴레이션을 생성하게 된다. 
이를 단계별로 구분하여 정규형이 높아질수록 이상현상은 줄어들게 된다.

제 1정규형: 도메인의 원자성, 각 컬럼이 하나의 속성만을 가져야 한다.
제 2정규형: 부분 함수적 종속 제거, 모든 컬럼이 완전 함수 종속을 만족해야 한다.
제 3정규형: 이행 함수적 종속 제거, 기본키를 제외한 속성들 간의 이행 종속성이 없어야 한다.
BCNF: 후보 키가 아닌 결정자 제거, 모든 결정자가 후보키 집합에 속해야 한다.
제 4정규형: 다치 종속이 없어야 한다. 다중값 종속을 제거하는 과정을 의미한다
제 5정규형: 조인 종속이 없어야 한다. 조인 연산을 수행 시 손실이 없어야 한다.

장점은 데이터베이스 변경 시 이상현산을 제거할 수 있다.
정규화된 DB에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
DB와 연동된 프로그램에 최소한의 영향만을 미치게 되어 프로그램의 생명을 연장시킨다.

단점은 여러 개의 릴레이션으로 분리된 경우 서로간의 JOIN연산이 많아진다.
질의에 대한 응답 시간이 느려질 수도 있다. 만약 JOIN이 많이 발생하여 성능의 저하가 나타나면 반정규화를 적용할 수 있다.